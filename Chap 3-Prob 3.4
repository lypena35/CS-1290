Chapter 3: Problem 3.4 Implement a MyQueue class which implements a queue using two stacks. 

I: We create a queue class or maybe modify the one in the book which implements a queue and we modify it by using two stacks that will act like a queue. The stack is last in first out and the queue is first in first out. We can basically use the second stack as a holding bin to emulate a queue since they are opposite of each other. Similar to if we fill up a bowl or a glass with two much of something we get another bowl or glass and we use it to help balance out that filled item. 
D: We need to create two stacks and we need to keep track of the size and we need to modify peek and pop so that we can do the opposite of what a stack usually does. In other words, we need to put everything into the empty stack from stack one into stack two and then we pop and push everything back to the old stack.  
E,A: Step 1: Works some small instances by hand:
         Say stack 1 is empty{}(just for a visual representation} and our new stack has 4 numbers push (1),(2),(5), then (3) and we pop because  3,5,2, and 1 into the empty stack so we have {3,5,2,1} and now we have a queue implementation because first in first out is now technically possible because our original stack has it reversed so the new stack can use pop the first in first out way and it’s the same as queue would be if we popping 1,2,5, and 3 into the queue. 
      Step 2: write down what you did:
     We need to create two stacks and then we need to create a method to get the size. Then we need a modified push method, but we need to modify it to take the newer stack, so we have to change it. Then a method to switch between the stacks which is putting all the stuff in stack 2 to stack 1 which is the stack that is empty and will help us to move everything over. Then we need a method to remove the stuff from the stack 1 back to stack 2. 

   Step 3: Find patterns
        We can see the pattern in how the two stacks act like a queue in flipping the variables essentially upside down. We also don’t really have to modify the pop and push much just make sure it goes to the right stack.

   Step 4: Check by hand
         Picture on attachment zip file. 

   Step 5: translate it to code
public class myQueue{
Stack stack1;//create stack 1
Stack stack2;//create stack 2

public void pushQ(stack item){
Stack2.push(item);//assuming we have a push method
}
public void moveStacks(){
if(stack1.isEmpty()){//assuming we have a isempty method that checks if the stack is empty
while(!stack2.isEmpty()){
       stack1.push(stack2.pop());//moving everything from one stack to the other
}
Public stack isQ(){
moveStacks();
return stack2.pop();//now we are popping in order of a queue.
}

Step 6: run test cases: 
Input: 
//again {} is just for visual representation
{} for stack 1
{1,3,6,5} for stack 2 pushing (1), (3), (6), and (5).
Output: {5,6,3,1}//so we are popping 5, then 6, 3, and 1.

Step 7: Debug failed test case:
      I am sure you can add a size method to keep track of the size and a peek method to peek in, but we just need to implement two stacks to work like a queue, so we are good with what we have. 
L: I really like this problem, I worked on this before in I believe cs 2. I think it’s really interesting how we can mimic a different data structure by using two of another is pretty cool. I am really curious about seeing other such things happening with other data structures. 
