Chapter 2: Problem 2.2 Return Kth to last: Implement an algorithm to find the kth to last element of a singly linked list.

I: We can print the elements of the linked list from k that we enter to the end of the linked list. 
D: We pass the head of the iNode if necessary if we have access to it then we only need to pass the integer k. We need to get the length, so we can use that to our advantage. Of course, we don’t mess with the head, so we always create a temp pointer if need be to traverse the array. Then while that temp node doesn’t equal null we traverse and count the length. Then we check if k is more than the length because we want to make sure we don’t get a null pointer exception. If it is, we just return and then we traverse the list and print from k to the end. 
E,A: Step 1: Works some small instances by hand:
        You have a linked list from 1->2->3->4 and k is 3 so we will only print 4. If we have an unsorted array 4->9->1->3 and say k is 1 so we would print 9,1, and 3. Or if we have k at 0 it will print the whole list since 4 is the head. Or if it was 11 we would just return. 

      Step 2: write down what you did:
             I basically did the same thing I wrote in D. Count the length of the list check to make sure k isn’t greater than the list and then we just traverse the list and print from k to the end. 

   Step 3: Fine patterns
            For sure we need a variable node pointer, so we don’t lose the head pointer and we need a while loop to make sure we don’t go over null. We also need to traverse the linked list and print it like any other method. 

   Step 4: Check by hand
On the compressed file attached. 
         

   Step 5: translate it to code
  public void printNthFromLast(iNode head,int k) {
            int getLength = 0;
            iNode temp = head;

            while (temp != null) {
                temp = temp.next;
                getLength++;
            }
            if (getLength < k) return;
            temp = head;
            for (int i = 1; i < getLength - k + 1; i++)//get the node from the beginning 
                temp = temp.next;

            System.out.println (temp.data);
        }
    }

Step 6: run test cases: 
Input: 5->6->10->1 and k is 2 we expect our output would be 10 and 1.
Output 10->1 was the output so we were good. 
Input was still the same but this time we changed k to 7 and we just return and print nothing since k is bigger than the length of the linked list. We expected that, so we are good. 

Step 7: Debug failed test case:
  I had to manipulate the for loop till I got the correct values of the length -k+1 because I kept getting errors. Once I fixed that everything worked. I am sure hash table would be more efficient. 
L: This is also another method I have seen a lot and worked on a lot in slight variations so I had a good idea on where to start and how to go about doing this.
